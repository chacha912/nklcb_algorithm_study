## 백준 #1167 트리의 지름

- 알고리즘 스터디 문제 풀이입니다.
- [백준 1167번](https://www.acmicpc.net/problem/1167) 에서 풀어볼 수 있습니다.

### 문제설명

트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.

트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.

먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.

```
Input
-----
5
1 3 2 -1
2 4 4 -1
3 1 2 4 3 -1
4 2 4 3 3 5 6 -1
5 4 6 -1

Output
------
11
```

### 풀이

해당 문제를 보고 처음에는 단순 dfs를 통해서 트리의 루트(혹은 리프)노드에서 다른 리프까지 탐색하는 과정을 통해서 최댓값을 찾을 수 있는지를 물어보는 문제인줄 알고 단순히 dfs를 통해서 아래와 같이 접근하려 해보았다.

하지만 시간초과가 나서, 다시 생각을 해보니 로직 중

```python
for i in range(len(adjList)):
    if len(adjList[i]) == 1:
        ans = max(ans, dfs(i, -2, 0))
```

해당 부분에서 인접한 노드가 1인 노드들, 즉 리프 노드와 루트노드 각각 모두 dfs를 돌려주어 시간초과가 난 것이었다. 입력되는 V의 범위가 100,000 이기 때문에 나의 방식은 O(V^2)이 된 것이었고, 시간초과가 나는 것은 당연한 결과였다.

그래서 어떻게든 다른 방법을 찾아야겠다고 생각했고, 단순히 완전 탐색이 아니라 지름을 구성하고 있는 양 꼭지점(?) 중 하나를 먼저 구할 수 있다는 힌트를 얻어 문제를 풀어주었다.

임의의 노드에서 가장 멀리 있는 노드(가중치의 합이 가장 큰 노드)가 지름을 구성하는 두 노드 중 하나라는 점이다. 이러한 힌트 및 증명은 [이 블로그](https://blog.myungwoo.kr/112)를 참고하였다.

따라서 bfs를 사용해 한 노드를 찾아주었고, 해당 노드에서 bfs를 한 번 더 수행해 해당 노드로부터의 가중치의 합(거리)를 구해주는 방식으로 문제를 풀어주었다.
